
import clientPromise, { connectMongoose, Analysis } from './mongodb'; // Assuming Analysis model might be used or relevant
// Placeholder for actual embedding generation if needed outside AI flow
// For now, we assume embeddings are generated by the AI flow and stored in FileAnalysisItem.

// This function is a placeholder for creating embeddings if not done by the main AI flow.
// The PRD implies Vertex AI generates the embedding alongside other analysis.
export async function createCodeEmbedding(code: string): Promise<number[]> {
  // This is a placeholder. In a real scenario, you'd call an embedding model (e.g., via Genkit or directly).
  // For a 768-dimension vector, this would be a much more sophisticated process.
  console.warn("Using placeholder for createCodeEmbedding. Replace with actual embedding model call.");
  const placeholderVector = Array(768).fill(0).map(() => Math.random() * 0.1); // Example random 768-dim vector
  placeholderVector[0] = code.length / 1000; // Add some variance based on code length
  return placeholderVector;
}

export async function findSimilarCode(queryVector: number[], limit = 5, similarityThreshold = 0.85) {
  await connectMongoose();
  const client = await clientPromise;
  const db = client.db(); // Use default DB from MONGODB_URI or specify if needed
  
  // Ensure queryVector is a valid array of numbers
  if (!Array.isArray(queryVector) || !queryVector.every(n => typeof n === 'number')) {
    console.error("Invalid queryVector provided to findSimilarCode.");
    return [];
  }

  // This query assumes:
  // 1. You have an Atlas Vector Search index named 'vector_search_analyses_files' (example name).
  // 2. This index is on the 'analyses' collection.
  // 3. The index is configured to search the 'fileAnalyses.vectorEmbedding' path.
  //    This means your 'analyses' documents have a 'fileAnalyses' array,
  //    and each object in that array has a 'vectorEmbedding' field.
  // 4. The vector embeddings are 768 dimensions.
  // IMPORTANT: You MUST create this vector search index in your MongoDB Atlas deployment.
  const pipeline = [
    {
      $vectorSearch: {
        index: "idx_file_embeddings", // REPLACE with your actual Atlas Vector Search index name
        path: "fileAnalyses.vectorEmbedding", // Path to the embedding field within the nested array
        queryVector: queryVector,
        numCandidates: limit * 15, // Number of candidates to consider initially
        limit: limit, // Number of results to return
        // similarityThreshold could be used here if desired, e.g. filter: { score: { $gte: similarityThreshold } }
        // but vectorSearch typically returns top N regardless of absolute score unless filtered.
        // The PRD example included similarityThreshold in the query, this is often handled by 'filter' or post-processing.
      }
    },
    {
      $unwind: "$fileAnalyses" // Unwind to work with individual files
    },
    { // Optional: Add a stage to calculate score for each unwound file if the index supports it per-element
      // Or, if the $vectorSearch score is per-document, you might need to re-score or ensure only matching file is processed
      $addFields: {
        "searchScore": { $meta: "vectorSearchScore" } // Capture the search score
      }
    },
    { // Filter based on threshold (if not done in $vectorSearch directly via filter)
        $match: {
            "searchScore": { $gte: similarityThreshold }
        }
    },
    { // Project the fields you need
      $project: {
        _id: 0, // Exclude the original document ID if not needed
        pullRequestId: 1,
        filename: "$fileAnalyses.filename",
        originalDocId: "$_id", // ID of the parent Analysis document
        qualityScore: "$fileAnalyses.qualityScore",
        aiInsights: "$fileAnalyses.aiInsights",
        // Include other relevant fields from fileAnalyses or the parent Analysis doc
        score: "$searchScore"
      }
    },
    { $sort: { score: -1 } }, // Ensure sorted by score
    { $limit: limit } // Ensure final limit
  ];

  try {
    // console.log("Executing Atlas Vector Search with pipeline:", JSON.stringify(pipeline, null, 2));
    const results = await db.collection('analyses').aggregate(pipeline).toArray();
    // console.log("Vector search results:", results);
    return results;
  } catch (error) {
    console.error("Error during Atlas Vector Search:", error);
    // Fallback or rethrow as appropriate
    // For now, returning empty array on error
    console.warn("Atlas Vector Search failed. Ensure your index 'idx_file_embeddings' is correctly configured on 'analyses' collection for path 'fileAnalyses.vectorEmbedding'.");
    return [];
  }
}

export async function setupVectorSearch() {
  await connectMongoose();
  // const client = await clientPromise;
  // const db = client.db();
  
  // MongoDB Atlas Vector Search index creation is typically done via the Atlas UI or Atlas Admin API,
  // not directly through client-side application code using `createIndex`.
  // The index definition would look something like this in JSON (for Atlas UI/API):
  /*
  {
    "name": "idx_file_embeddings", // Or your chosen index name
    "collectionName": "analyses", // The collection to index
    "database": "codexairdb",    // Your database name
    "definition": {
      "fields": [
        {
          "type": "vector",
          "path": "fileAnalyses.vectorEmbedding", // Path to the field containing embeddings
          "numDimensions": 768,       // Dimension of your vectors
          "similarity": "cosine"      // Or "euclidean" or "dotProduct"
        }
        // You can add other fields to filter on, e.g.,
        // {
        //   "type": "filter",
        //   "path": "pullRequestId" 
        // }
      ]
    }
  }
  */
  console.log('MongoDB Atlas Vector Search index setup guide:');
  console.log('1. Go to your MongoDB Atlas cluster.');
  console.log('2. Select the database (e.g., "codexairdb").');
  console.log('3. Go to the "Search" tab and click "Create Search Index".');
  console.log('4. Choose "Atlas Vector Search" visual editor or JSON editor.');
  console.log('5. Configure the index for the "analyses" collection.');
  console.log('   - Index Name: e.g., idx_file_embeddings');
  console.log('   - Target Field Path for vector: fileAnalyses.vectorEmbedding');
  console.log('   - Number of Dimensions: 768');
  console.log('   - Similarity Metric: cosine (or as appropriate)');
  console.log('Ensure this setup is complete for vector search functionality to work.');
}

// Call setupVectorSearch on startup for informational purposes if desired,
// but it doesn't create the index, just logs instructions.
// setupVectorSearch(); // You might call this once when the app starts, or log it.
